*THIS PAGE IS UNDER CONSTRUCTION*

*LAST UPDATE: Sep 21, 2013*

This document is based on the development version and should be considered as a technical specification document. As a consequence, a number of features could be absent from the last stable release and marked as _deprecated_ or _upcoming_ in the following documentation. See the [ChangeLog] and the [ToDoList] for further details.

== Arguments ==

To use _proxyshark_, simply run the Python script _proxyshark.py_. You can use the following arguments (all optional):

==== `-h | --help` ====

 Print a short help describing the available command-line arguments.

==== `-l | --logging [<target>][,<target][...]` ====

 Enable logging to the specified targets. A target can be either "_console_" or "_file=`<filename>`_".

 Default is _console_.

==== `-v | --verbose` ====

 Turn on verbose mode. Can be specified several times to increase verbosity:
  * 0 = errors only (quiet mode)
  * 1 = information + warnings
  * 2 = debug mode
  * 3 = debug mode + XML dissection

 Default is _on (level 1)_.

==== `-e | --ethernet` ====

 Turn on Ethernet mode. If enabled, an Ethernet layer will be automatically generated for all captured packets. Otherwise, packets will start at layer 3 (IP). In fact, enabling this mode is only required if you plan to replay packets at layer 2.

 For those who are interested, this mode is handled with Scapy.

 Default is _off_.

==== `-q | --queue-num <queue-num>` ====

 Select the _netfilter_ queue to use.

 Default is _1234_.

==== `-t | --tshark-path <tshark-path>` ====

 Set the location of the _tshark_ binary to use for packet dissection.

 Default is _./bin/`<arch>`_ where _`<arch>`_ is the current architecture (i686, _x86_64_, etc). If not found, _tshark_ is taken from _$PATH_.

==== `-w | --web-driven-mode [<bind-address>]:[<listening-port]:[proxy-address]:[proxy-port]` ====

 Turn on web-driven mode. In this mode, a local web service will wait for incoming requests from _proxyshark_. The idea is to ask _proxyshark_ to call this web service each time a packet is captured so that we can use a tool such as Burp Suite Pro to handle them.

 Default is _off_. If enabled, default parameters are:
  * _`<bind-address>`_ = _127.0.0.1_
  * _`<listening-port>`_ = _1234_
  * _`<proxy-address>`_ = _127.0.0.1_
  * _`<proxy-port>`_ = _8080_

 Note that all parameters are optional and that _-w :::_ is allowed.

==== `-c | --capture-filter <capture-filter>` ====

 Set the capture filter. This filter will be used at a netfilter level to select which packets have to be captured. Basically, you just have to provide a [http://en.wikipedia.org/wiki/Berkeley_Packet_Filter BPF filter] in _`<capture-filter>`_ and _proxyshark_ will use it to generate appropriate _iptables_ rules targeting the _NFQUEUE_ target.

 Default is no filter (or _ip_).

==== `-p | --packet-filter <packet-filter>` ====

 Set the packet filter. This filter is almost like a _Wireshark_ filter. You can use it to select captured packets based on dissection criteria. For example, a valid filter would be _http.request.method=GET and http.request.uri=/_. Further details can be found [PacketFilters here].

 Default is no filter.

==== `-f | --field-filter <field-filter>` ====

 Set the field filter (only available in web-driven mode). This filter is a regular expression that selects which fields are sent to the web proxy (and which ones will be editable/repeatable).

 Default is no filter.

==== `-r | --run` ====

 Run the capture at start.

==== `-b | --breakpoint <packet-filter>` ====

 Define a default breakpoint based on the given packet filter (see the _--packet-filter_ argument and the _breakpoints_ documentation below).

==== `-a | --action <expression>` ====

 An action to run when the default breakpoint is reached (see the _--breakpoint_ argument and the _actions_ documentation below).

==== `<filename>` ====

 The name of an optional script to run (see the _scripting_ documentation below).

==== Examples ====

 Run _proxyshark_ in command-line mode:

 {{{
python proxyshark.py -v
 }}}

 Run proxyshark on queue 123 in web-based mode and port 8080:

 {{{
python proxyshark.py -v -q 123 -w -p 8080
 }}}

== Command-line interface `[UPCOMING]` ==

The command-line interface allows the user to setup breakpoints and to interactively manipulate the captured packets.

Several commands are available:

==== `h | help [command]` ====

 Print a help message describing the available commands. You can specify an optional command name to get information about a specific command.

==== `i | info` ====

 Print information about the current program state:
  * BPF filter and netfilter rules
  * breakpoints and associated actions
  * statistics

 See the [TechnicalDescription technical description] for details about BPF filters, netfilter rules, breakpoints and actions.

==== `b | breakpoint <breakpoint-id> [filter-expression]` ====

 Create a new breakpoint based on the given expression. The first argument is the identifier of the new breakpoint. If no expression is given, print a list of the existing breakpoints. See the [TechnicalDescription technical description] for details about breakpoints.

==== `a | action <breakpoint-id> [python-code]` ====

 Associate a new action with a breakpoint. The first argument must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_. The second argument is the code to execute when the action is triggered. If no code is given, print the action associated with the breakpoint. See the [TechnicalDescription technical description] for details about actions and breakpoints.

==== `c | capture [bpf-filter]` ====

 Start a new capture. The argument will be parsed as a BPF filter and converted into a set of netfilter rules redirecting the matching packets to the selected netfilter queue. See the [TechnicalDescription technical description] for details about BPF filters and netfilter rules.

==== `en | enable <breakpoint-id>` ====

 Enable an existing breakpoint. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_.

==== `dis | disable <breakpoint-id>` ====

 Disable an existing breakpoint. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_. 

==== `d | delete <type> <breakpoint-id>` ====

 Delete a breakpoint or an action. The _type_ argument can be _b_ or _breakpoint_ for a breakpoint and _a_ or _action_ for an action. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_.

==== `pkts | packets <filter-expression>` ====

 Return all the previously captured packets. You can specify a filter expression to select a subset of packets. See the [TechnicalDescription technical description] for details about filter expressions.

==== `pkt | packet` ====

 A special variable containing the last dissected packet.

==== `accept` ====

 Accept the current packet and resume the capture.

==== `drop` ====

 Drop the current packet and resume the capture.

==== `break` ====

 Pause the current capture.

==== `stop` ====

 Stop the current capture.

==== Examples ====

 Capture HTTP traffic from or to _www.google.com_ and break on index requests:

 {{{
>>> b 1 pkt.http.method == "GET" and pkt.http.uri == "/"
new breakpoint with id 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> c host www.google.com and port 80
capturing...
at breakpoint 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> 
 }}}

 Print the captured packet:

 {{{
>>> pkt
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET / HTTP/1.1
>>> print pkt
[todo: put the dissected fields here]
 }}}

 Modify the URI and let the packet go:

 {{{
>>> pkt.http.uri = "/modified.php"
>>> pkt
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET /modified.php HTTP/1.1
>>> accept
capturing...
 }}}

 Automatically modify the URI when an index request is encountered:

 {{{
>>> b 1 pkt.http.method == "GET" and pkt.http.uri == "/"
new breakpoint with id 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> a 1 pkt.http.uri = "/modified.php"; accept()
new action on breakpoint 1: pkt.http.uri = "/modified.php"; accept()
>>> c host www.google.com and port 80
capturing...
at breakpoint 1: running action
at breakpoint 1: running action
at breakpoint 1: running action
 }}}

 Get all the TCP packets:

 {{{
>>> pkts pkt.tcp
[4 packets]
0.000000 192.168.98.102 -> 74.125.39.104 TCP 56511 > http [SYN] Seq=0 Win=5840 Len=0 MSS=1460 TSV=8507835 TSER=0 WS=1
0.048718 74.125.39.104 -> 192.168.98.102 TCP http > 56511 [SYN, ACK] Seq=0 Ack=1 Win=5672 Len=0 MSS=1430 TSV=2275473486 TSER=8507835 WS=6
0.048905 192.168.98.102 -> 74.125.39.104 TCP 56511 > http [ACK] Seq=1 Ack=1 Win=5840 Len=0 TSV=8507840 TSER=2275473486
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET / HTTP/1.1
 }}}

 Get the TCP packets where the SYN flag is set:

 {{{
>>> pkts pkt.tcp.flags.syn
 }}}
 
 Get the HTTP packets where the TTL is _64_, the method is _POST_ and the URI is _/index.php_:

 {{{
>>> pkts pkt.ip.ttl == 64 and pkt.http.method == "POST" and pkt.http.uri == "/index.php"
 }}}

== Scripting interface `[UPCOMING]` ==

You can also write Python scripts based on proxyshark. The available functions are the same than in command-line mode.

==== Example ====

 {{{
#!~/proxyshark.py -v

# define a complex action
def myaction():
    pkt.ip.ttl = 64
    pkt.http.uri = "/modified.php"
    # add any other action here
    # ...
    # accept the packet
    accept()
    # stop the capture after 10 packets
    if len(pkts) == 10:
        print "Capture done."
        stop()

# define a breakpoint and an action
b mybreak pkt.http.method == "GET" and pkt.http.uri == "/"
a mybreak myaction()

# run the capture
c host www.google.fr and port 80
print "End."
 }}}

 {{{
root@debian:~$ python proxyshark.py -v myscript.py
new breakpoint with id 'mybreak': pkt.http.method == "GET" and pkt.http.uri == "/"
new action on breakpoint 'mybreak': myaction()
capturing...
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
Capture done.
End.
root@debian:~$
 }}}