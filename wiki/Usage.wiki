*THIS PAGE IS UNDER CONSTRUCTION*

*LAST UPDATE: Sep 21, 2013*

This document is based on the current development version of _proxyshark_ and should be considered as a technical specification document. As a consequence, a number of features could be absent from the last stable release and marked as _deprecated_ or _upcoming_ in the following documentation. See the [ChangeLog] and the [ToDoList] for further details.

== Command-line arguments ==

To use _proxyshark_, simply run the Python script _proxyshark.py_. You can also use the following optional arguments (see the documentation about the interactive mode for details about each parameter):

==== `-h | --help` ====

 Print a short help describing the available command-line arguments.

 Default is _off_.

==== `-l | --logging [<handler>][,<handler>][...]` ====

 Enable the specified logging handlers. A handler can be either "_console_", "_file=`<`filename`>`_", "_syslog_" or "_syslog=`<`ip`>`:`<`port`>`_".

 Default is _console_.

==== `-v | --verbose` ====

 Turn on verbose mode. Can be specified several times to increase verbosity.

 Default is _on (level 1)_.

==== `-e | --ethernet` ====

 Turn on Ethernet mode.

 Default is _off_.

==== `-q | --queue-num <queue-num>` ====

 Select the _netfilter_ queue to use.

 Default is _1234_.

==== `-t | --tshark-path <tshark-path>` ====

 Set the location of the _tshark_ binary to use for packet dissection.

 Default is _./bin/`<`arch`>`_ where _`<`arch`>`_ is the current architecture (i686, _x86_64_, etc). If not found, _tshark_ is taken from _$PATH_.

==== `-w | --web-driven-mode [<bind-address>]:[<listening-port>]:[<proxy-ip>]:[<proxy-port>]` ====

 Turn on web-driven mode.

 Default is _off_. If enabled, default parameters are:
  * _`<bind-address>`_ = _127.0.0.1_
  * _`<listening-port>`_ = _1234_
  * _`<proxy-ip>`_ = _127.0.0.1_
  * _`<proxy-port>`_ = _8080_

 Note that all of them are optional and that _:::_ is allowed.

==== `-c | --capture-filter <capture-filter>` ====

 Set the capture filter.

 Default is no filter (or _ip_).

==== `-p | --packet-filter <packet-filter>` ====

 Set the packet filter.

 Default is no filter.

==== `-f | --field-filter <field-filter>` ====

 Set the field filter (only available in web-driven mode).

 Default is no filter.

==== `-r | --run` ====

 Automatically run capture at start.

 Default is _off_.

==== `-b | --breakpoint <packet-filter>` ====

 Define a default breakpoint based on the given packet filter.

 Default is no breakpoint.

==== `-a | --action <expression>` ====

 An action to run when the default breakpoint is reached.

 Default is no action.

==== [`<filename>`] ====

 An optional script to run at start.

 Default is no script.

==== Examples ====

 Run _proxyshark_ from the command-line (interactive mode):

 {{{
python proxyshark.py --verbose
 }}}

 Capture SIP traffic in web-driven mode with local web proxy running on port 8888:

 {{{
python proxyshark.py -v --capture-filter 'port 5060' --packet-filter 'sip' --web-driven-mode :::8888 --run
 }}}

 Turn all HTTP responses into "HTTP 500" errors:

 {{{
python proxyshark.py -v -c 'port 80' -p 'http.response.code' -r --breakpoint 'any' --action 'http.response.code=500;continue'
 }}}

== Interactive console ==

You can enter the interactive mode by running _proxyshark_ without the _--run_ argument or by pressing Ctrl-C in view mode. It allows the user to manipulate packets, change settings dynamically, setup breakpoints and so on.

Several commands are available:

==== `set verbose|verbosity [level] <0|1|2|3>` ====

 Set the verbosity level to one of the following values:
  * `0` for errors only (quiet mode)
  * `1` for information and warnings
  * `2` for debug mode
  * `3` for debug mode and XML dissection

==== `set ethernet [mode] <off|on|0|1>` ====

 Enable or disable Ethernet mode. If enabled, an Ethernet layer will be automatically generated for all captured packets. Otherwise, packets will start at layer 3 (IP). In fact, enabling this mode is only required if you plan to replay packets at layer 2.

==== `set queue|nfqueue [number] <queue-number>` ====

 Select the _netfilter_ queue to use (the keyword _number_ is optional).

==== `set tshark [path] <tshark-path>` ====

 Set the location of the _tshark_ binary to use for packet dissection.

==== `set web|web-driven [mode] [<bind-address>]:[<listening-port>]:[<proxy-ip>]:[<proxy-port>]` ====

 Enable or disable web-driven mode. In this mode, an embedded web server will wait for incoming requests from _proxyshark_ itself. The idea is to ask _proxyshark_ to call this web service each time a packet is captured so that we can use a tool such as Burp Suite Pro to handle them.

 The parameters are:
  * _`<`bind-address`>`_: binding address of the embedded web server
  * _`<`listening-port`>`_: listening port of the embedded web server
  * _`<`proxy-ip`>`_: ip address of the web proxy to use
  * _`<`proxy-port`>`_: port of the web proxy to use

 Note that all of them are optional and that _:::_ is allowed.

==== `set bind|binding ip|addr|address <bind-address>` | `set bind|binding port <bind-port>` | `set proxy ip|addr|address|host <proxy-ip>` | `set proxy port <proxy-port>` ====

 Set the parameters of the web-driven mode individually.

==== `set capture filter <capture-filter>` ====

 Set the capture filter. This filter will be used at a _netfilter_ level to select which packets will be captured. Basically, you just have to provide a [http://en.wikipedia.org/wiki/Berkeley_Packet_Filter BPF filter] in _`<capture-filter>`_ and _proxyshark_ will use it to generate appropriate _iptables_ rules targeting the _NFQUEUE_ target.

 The grammar is:
  * `CaptureFilter` => `[`*any* | `BooleanKeyword]`
  * `BooleanKeyword` => *not* `Keyword` | `Keyword` *and* `Keyword` | `Keyword` *or* `Keyword`
  * `Keyword` => `Device` | `Host` | `Network` | `Port` | `Protocol`
  * `Device` => `[`*in* | *out*`]` *dev* `BooleanValue`
  * `Host` => `[`*src* | *dst*`]` *host* `BooleanValue`
  * `Network` => `[`*src* | *dst*`]` *net* `BooleanValue`
  * `Port` => `[`*src* | *dst*`]` *port* `BooleanValue`
  * `Protocol` => *ip* | *icmp* | *tcp* `[Port]` | *udp* `[Port]`
  * `BooleanValue` => *not* *`<`value`>`* | *`<`value`>`* *and* *`<`value`>`* | *`<`value`>`* *or* *`<`value`>`*

 Values can be:
  * `Device` => `[`_alphas_`][`_alphanums_-.`_]*`
  * `Host` => `IpAddr` | `[`_alphas_`][`_alphanums_-.`_]*`
  * `Network` => `IpAddr` */* ( `IpAddr` | `[`_nums_`]{`1,2`}` ) | `IpAddr` *netmask* `IpAddr`
  * `Port` => `[`_nums_`]{`1,5`}`

 With:
  * `IpAddr` => `[`_nums_`]{`1,3`}` *.* `[`_nums_`]{`1,3`}` *.* `[`_nums_`]{`1,3`}` *.* `[`_nums_`]{`1,3`}`

===== Examples =====

 Capture HTTP traffic:

 {{{
tcp port 80 or 443
 }}}

 Capture SIP requests from _10.0.0.0/8_ to _1.2.3.4_ and _2.3.4.5_ on network device _eth1_:

 {{{
dev eth1 and src net 10.0.0.0/8 and dst host 1.2.3.4 or 2.3.4.5 and udp dst port 5060
 }}}

 {{{
[DEBUG] iptables -t filter -A PROXYSHARK9213 -j NFQUEUE --queue-num 1234
[DEBUG] iptables -t filter -A PROXYSHARK6054 -p udp --dport 5060 -j PROXYSHARK9213
[DEBUG] iptables -t filter -A PROXYSHARK1240 -d 2.3.4.5 -j PROXYSHARK6054
[DEBUG] iptables -t filter -A PROXYSHARK1240 -d 1.2.3.4 -j PROXYSHARK6054
[DEBUG] iptables -t filter -A PROXYSHARK9274 -s 10.0.0.0/8 -j PROXYSHARK1240
[DEBUG] iptables -t filter -A PROXYSHARK5027 -o eth1 -j PROXYSHARK9274
[DEBUG] iptables -t filter -A PROXYSHARK5027 -i eth1 -j PROXYSHARK9274
[DEBUG] iptables -t filter -I INPUT 1 -j PROXYSHARK5027
[DEBUG] iptables -t filter -I OUTPUT 1 -j PROXYSHARK5027
[DEBUG] iptables -t filter -I FORWARD 1 -j PROXYSHARK5027
 }}}

==== `set packet filter <packet-filter>` ====

 Set the packet filter. This filter is almost like a _Wireshark_ filter. You can use it to select captured packets based on dissection criteria.

 The grammar is:
  * `PacketFilter` => `[`*any* | `BooleanCondition]`
  * `BooleanCondition` => `Operand` `[Operator` `Value]`
  * `Operand` => `Item` | `[`( *len* | *nb* ) *(* `Item` *)*`]`
  * `Item` => `ItemName` `[`*`[`* `AttributeName` *`]`*`]` `[`*`[`* `SliceKey` *`]`*`]`
  * `ItemName` => `[`_alpha_.`_]`+
  * `AttributeName` => `[`_alpha_`]`+
  * `SliceKey` => `[`-_nums_`]*` *:* `[`-_nums_`]*`
  * `Operator` => *`==`* | *`=`* | *`!=`* | *`^=`* | *`*=`* | *`$=`* | *`<=`* | *`<`* | *`>=`* | *`>`*
  * `Value` => `QuotedValue` | `UnquotedValue`
  * `QuotedValue` => `"[`_printable_`]`+`"` | `'[`_printable_`]`+`'`
  * `UnquotedValue` => `[`_printable_without_space_`]`+

===== Examples =====

 Select ICMP packets with TTL < 32:

 {{{
icmp and ip.ttl < 32
 }}}

 Select HTTP GET requests for URI starting with _/index.php?page=_ and with a User-Agent shorter than 10 characters:

 {{{
http.request.method=GET and http.request.uri^=/index.php?page= and len(http.user_agent) < 10
 }}}

==== `set field filter <field-filter>` ====

 Set the field filter. In web-driven mode, this filter is just a [http://docs.python.org/2/howto/regex.html regular expression] that selects which items of the packets (protocols or fields) will be sent to the web proxy (which ones will be editable/repeatable).

 Note: if no `^` or `$` are found in the string, they will be added automatically at the beginning or at the end of the filter.

===== Examples =====

 Forward only the fields related to SIP:

 {{{
sip.*
 }}}


 Forward only the IP and TCP protocols, and all the fields from the HTTP layer:

 {{{
ip$|tcp$|http.*
 }}}

==== `h | help [command]` ====

 Print a help message describing the available commands. You can specify an optional command name to get information about a specific command.

==== `i | info` ====

 Print information about the current program state:
  * BPF filter and netfilter rules
  * breakpoints and associated actions
  * statistics

 See the [TechnicalDescription technical description] for details about BPF filters, netfilter rules, breakpoints and actions.

==== `b | breakpoint <breakpoint-id> [filter-expression]` ====

 Create a new breakpoint based on the given expression. The first argument is the identifier of the new breakpoint. If no expression is given, print a list of the existing breakpoints. See the [TechnicalDescription technical description] for details about breakpoints.

==== `a | action <breakpoint-id> [python-code]` ====

 Associate a new action with a breakpoint. The first argument must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_. The second argument is the code to execute when the action is triggered. If no code is given, print the action associated with the breakpoint. See the [TechnicalDescription technical description] for details about actions and breakpoints.

==== `c | capture [bpf-filter]` ====

 Start a new capture. The argument will be parsed as a BPF filter and converted into a set of netfilter rules redirecting the matching packets to the selected netfilter queue. See the [TechnicalDescription technical description] for details about BPF filters and netfilter rules.

==== `en | enable <breakpoint-id>` ====

 Enable an existing breakpoint. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_.

==== `dis | disable <breakpoint-id>` ====

 Disable an existing breakpoint. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_. 

==== `d | delete <type> <breakpoint-id>` ====

 Delete a breakpoint or an action. The _type_ argument can be _b_ or _breakpoint_ for a breakpoint and _a_ or _action_ for an action. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_.

==== `pkts | packets <filter-expression>` ====

 Return all the previously captured packets. You can specify a filter expression to select a subset of packets. See the [TechnicalDescription technical description] for details about filter expressions.

==== `pkt | packet` ====

 A special variable containing the last dissected packet.

==== `accept` ====

 Accept the current packet and resume the capture.

==== `drop` ====

 Drop the current packet and resume the capture.

==== `break` ====

 Pause the current capture.

==== `stop` ====

 Stop the current capture.

==== Examples ====

 Capture HTTP traffic from or to _www.google.com_ and break on index requests:

 {{{
>>> b 1 pkt.http.method == "GET" and pkt.http.uri == "/"
new breakpoint with id 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> c host www.google.com and port 80
capturing...
at breakpoint 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> 
 }}}

 Print the captured packet:

 {{{
>>> pkt
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET / HTTP/1.1
>>> print pkt
[todo: put the dissected fields here]
 }}}

 Modify the URI and let the packet go:

 {{{
>>> pkt.http.uri = "/modified.php"
>>> pkt
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET /modified.php HTTP/1.1
>>> accept
capturing...
 }}}

 Automatically modify the URI when an index request is encountered:

 {{{
>>> b 1 pkt.http.method == "GET" and pkt.http.uri == "/"
new breakpoint with id 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> a 1 pkt.http.uri = "/modified.php"; accept()
new action on breakpoint 1: pkt.http.uri = "/modified.php"; accept()
>>> c host www.google.com and port 80
capturing...
at breakpoint 1: running action
at breakpoint 1: running action
at breakpoint 1: running action
 }}}

 Get all the TCP packets:

 {{{
>>> pkts pkt.tcp
[4 packets]
0.000000 192.168.98.102 -> 74.125.39.104 TCP 56511 > http [SYN] Seq=0 Win=5840 Len=0 MSS=1460 TSV=8507835 TSER=0 WS=1
0.048718 74.125.39.104 -> 192.168.98.102 TCP http > 56511 [SYN, ACK] Seq=0 Ack=1 Win=5672 Len=0 MSS=1430 TSV=2275473486 TSER=8507835 WS=6
0.048905 192.168.98.102 -> 74.125.39.104 TCP 56511 > http [ACK] Seq=1 Ack=1 Win=5840 Len=0 TSV=8507840 TSER=2275473486
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET / HTTP/1.1
 }}}

 Get the TCP packets where the SYN flag is set:

 {{{
>>> pkts pkt.tcp.flags.syn
 }}}
 
 Get the HTTP packets where the TTL is _64_, the method is _POST_ and the URI is _/index.php_:

 {{{
>>> pkts pkt.ip.ttl == 64 and pkt.http.method == "POST" and pkt.http.uri == "/index.php"
 }}}

== Scripting interface `[UPCOMING]` ==

You can also write Python scripts based on proxyshark. The available functions are the same than in command-line mode.

==== Example ====

 {{{
#!~/proxyshark.py -v

# define a complex action
def myaction():
    pkt.ip.ttl = 64
    pkt.http.uri = "/modified.php"
    # add any other action here
    # ...
    # accept the packet
    accept()
    # stop the capture after 10 packets
    if len(pkts) == 10:
        print "Capture done."
        stop()

# define a breakpoint and an action
b mybreak pkt.http.method == "GET" and pkt.http.uri == "/"
a mybreak myaction()

# run the capture
c host www.google.fr and port 80
print "End."
 }}}

 {{{
root@debian:~$ python proxyshark.py -v myscript.py
new breakpoint with id 'mybreak': pkt.http.method == "GET" and pkt.http.uri == "/"
new action on breakpoint 'mybreak': myaction()
capturing...
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
Capture done.
End.
root@debian:~$
 }}}