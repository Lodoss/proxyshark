*THIS PAGE IS UNDER CONSTRUCTION*

*LAST UPDATE: Sep 22, 2013*

This document is based on the current development version of _proxyshark_ and should be considered as a technical specification document. As a consequence, a number of features could be absent from the last stable release and marked as `[DEPRECATED]` or `[UPCOMING]` in the following documentation. See the [ChangeLog] and the [ToDoList] for further details.

First of all, you have to know that _proxyshark_ can be used in 4 different modes:
 * *View mode*: all you have to do here is run _proxyshark_ with the appropriate arguments and watch the result in your favorite shell. You can setup filters and schedule simple actions based on given conditions, but nothing too complicated. For example, you can define an action to automatically replace all occurrences of a given value in a given packet field by another value. You can switch to this mode by running _proxyshark_ with the _[#-r_%7C_--run --run]_ argument or by pressing Ctrl-D in interactive mode (see below).
 * *Interactive mode*: this mode is very close to the view mode except that you can use an embedded shell to change settings and manipulate packets dynamically. For example, you can search for specific packets in cache, modify them, replay them or even free memory by removing them from cache. To switch in interactive mode, just run _proxyshark_ without the _[#-r_%7C_--run --run]_ argument or press Ctrl-C when running in view mode.
 * *Scripting mode* *`[UPCOMING]`*: you can specify a Python script to run as [#%5B_%3Cfilename%3E_%5D last command-line argument]. All commands available in [#Interactive_console interactive mode] are also available here and will be interpreted. Note that you will switch to view mode after the script being finished.
 * *Web-driven mode*: a bit more complicated, here _proxyshark_ will generate an HTTP POST request to its own web service each time a packet is captured. The idea is to send this request through a local proxy to offer the possibility of handling captured packets through a GUI. All powerful tools provided by such proxy will be available too (for example, the Scanner, Intruder and Repeater from [http://portswigger.net/ Burp Suite Pro]). Of course you will need the appropriate extension, or you will have to manipulate raw HTTP requests... Fortunately, an extension for Burp Suite Pro will be provided with _proxyshark_ *`[UPCOMING]`*. To use this mode, you either have to specify a _[#-w_%7C_--web-driven-mode_%5B%3Cbind-ip%3E%5D%3A%5B%3Cbind-port%3E%5D%3A%5B%26l --web-driven-mode]_ argument or to [#set_web-driven-mode_%3Coff%7Con%7C0%7C1%3E enable it] from the interactive console. Note that web-driven mode can be used in parallel with any other.

== Command-line arguments ==

To use _proxyshark_, simply run the Python script _proxyshark.py_.

You can also use the following optional arguments (see [#Interactive_console interactive mode] documentation for details about each parameter):

==== `-h | --help` ====

 Print a short help describing the available command-line arguments.

==== `-l | --logging [<handler>][,<handler>][...]` ====

 Enable the specified [#set_logging_%5B%3Chandler%3E%5D%5B%2C%3Chandler%3E%5D%5B...%5D logging handlers].

 Default is _console_.

==== `-v | --verbose` ====

 Can be specified several times to increase the [#set_verbosity_%3C0%7C1%7C2%7C3%3E verbosity level].

 Default is _on (level 1)_ in view mode and _off (level 0)_ in interactive mode.

==== `-e | --ethernet` ====

 Turn on [#set_ethernet_%3Coff%7Con%7C0%7C1%3E Ethernet mode].

 Default is _off_.

==== `-q | --queue-num <queue-num>` ====

 Set the _[http://www.iptables.info/en/iptables-targets-and-jumps.html#NFQUEUETARGET netfilter queue]_ to use.

 Default is _1234_.

==== `-t | --tshark-path <tshark-path>` ====

 Set the location of the _tshark_ binary to use for packet dissection.

 Default is _./bin/`<`arch`>`_ where _`<`arch`>`_ is the current architecture (i686, _x86_64_, etc). If not found, _tshark_ is taken from $PATH.

==== `-w | --web-driven-mode [<bind-ip>]:[<bind-port>]:[<proxy-ip>]:[<proxy-port>]` ====

 Turn on [#set_web-driven-mode_%3Coff%7Con%7C0%7C1%3E web-driven mode].

 Default is _off_. If enabled, default parameters are:
  * _`<bind-ip>`_ = _127.0.0.1_
  * _`<bind-port>`_ = _1234_
  * _`<proxy-ip>`_ = _127.0.0.1_
  * _`<proxy-port>`_ = _8080_

 Note that all of them are optional and that _:::_ is allowed.

==== `-c | --capture-filter <capture-filter>` ====

 Set the [#set_capture_filter_%3Ccapture-filter%3E capture filter].

 Default is no filter (or _any_, or _ip_).

==== `-p | --packet-filter <packet-filter>` ====

 Set the [#set_packet_filter_%3Cpacket-filter%3E packet filter].

 Default is no filter (or _any_, or _ip_).

==== `-f | --field-filter <field-filter>` ====

 Set the [#set_field_filter_%3Cfield-filter%3E field filter] (only available in web-driven mode).

 Default is no filter (or _.`*`_).

==== `-r | --run` ====

 Automatically run capture at start then switch to view mode.

 Default is _off_.

==== `-b | --breakpoint <packet-filter>` ====

 Define a default [#b%7Cbreakpoint_%5B%3Cbreakpoint-id%3E%5D%7C%5B%3Cbreakpoint-id%3E_%3C breakpoint] based on the given packet filter.

 Default is no breakpoint.

==== `-a | --action <expression>` ====

 An [#a%7Caction_%5B%3Caction-id%3E%5D%7C%5B%3Caction-id%3E_%3Cbreakpoint-i action] to run when the default breakpoint is reached.

 Default is no action.

==== [`<filename>`] ====

 An optional script to run at start (scripting mode).

 Default is no script.

==== Examples ====

 Run _proxyshark_ in interactive mode:

 {{{
python proxyshark.py --verbose
 }}}

 Capture SIP traffic in web-driven mode with local web proxy running on port 8888 (view mode):

 {{{
python proxyshark.py -v --capture-filter 'port 5060' --packet-filter 'sip' --web-driven-mode :::8888 --run
 }}}

 Turn all HTTP responses into "HTTP 500" errors (view mode):

 {{{
python proxyshark.py -v -c 'port 80' -p 'http.response.code' -r --breakpoint 'any' --action 'http.response.code=500;continue'
 }}}

== Interactive console ==

Several commands are available:

==== `h|help [command]` ====

 Print a short help describing the available commands, or a particular one if specified in argument.

==== `i|info [parameter]` ====

 Print information about the current program state:
  * Verbosity level
  * Ethernet mode
  * _Netfilter_ queue
  * _Tshark_ path
  * Web-driven mode and associated parameters
  * Filters at capture, packet and field levels
  * Breakpoints and actions
  * Cache

 You can specify an optional parameter to get information about it. Available parameters are:
  * `verbosity`
  * `ethernet`
  * `queue`
  * `tshark`
  * `web-driven`
  * `bind ip`
  * `bind port`
  * `proxy ip`
  * `proxy port`
  * `capture filter`
  * `packet filter`
  * `field filter`
  * `breakpoints`
  * `actions`
  * `cache`

==== `set logging [<handler>][,<handler>][...]` ====

 Set the current logging handlers.

 A handler can be either "_console_", "_file=`<`filename`>`_", "_syslog_" or "_syslog=`<`ip`>`:`<`port`>`_".

==== `set verbosity <0|1|2|3>` ====

 Set the verbosity level to one of the following values:
  * `0` for errors only (quiet mode)
  * `1` for information and warnings
  * `2` for debug
  * `3` for debug and XML dissection

==== `set ethernet <off|on|0|1>` ====

 Enable or disable Ethernet mode.

 If enabled, an Ethernet layer will be automatically generated for all captured packets. Otherwise, packets will start at layer 3 (IP). Enabling this mode is only required if you plan to replay packets at layer 2.

==== `set queue <queue-number>` ====

 Set the _[http://www.iptables.info/en/iptables-targets-and-jumps.html#NFQUEUETARGET netfilter queue]_ to use.

==== `set tshark <tshark-path>` ====

 Set the location of the _tshark_ binary to use for packet dissection.

 If not found, _tshark_ is taken from _$PATH_.

==== `set web-driven-mode <off|on|0|1>` ====

 Enable or disable web-driven mode.

 In this mode, an embedded web server will wait for incoming requests from _proxyshark_ itself. The idea is to ask _proxyshark_ to call this web service each time a packet is captured so that we can use a tool such as Burp Suite Pro to handle them.

==== `set bind ip <bind-ip>` | `set bind port <bind-port>` | `set proxy ip <proxy-ip>` | `set proxy port <proxy-port>` ====

 Set parameters of the web-driven mode. The available parameters are:
  * _`<`bind-ip`>`_: binding address of the embedded web server
  * _`<`bind-port`>`_: listening port of the embedded web server
  * _`<`proxy-ip`>`_: IP address of the web proxy to use
  * _`<`proxy-port`>`_: port of the web proxy to use

 Note that all of them are optional and that _:::_ is allowed.

==== `set capture filter <capture-filter>` ====

 Set the capture filter.

 This filter will be used at a _netfilter_ level to select which packets will be captured. Basically, you just have to provide a [http://en.wikipedia.org/wiki/Berkeley_Packet_Filter BPF filter] and _proxyshark_ will use it to generate appropriate _iptables_ rules targeting the _NFQUEUE_ target.

 The formal grammar is:
  * `CaptureFilter` => `[`*any* | `BooleanKeyword]`
  * `BooleanKeyword` => *not* `Keyword` | `Keyword` *and* `Keyword` | `Keyword` *or* `Keyword`
  * `Keyword` => `Device` | `Host` | `Network` | `Port` | `Protocol`
  * `Device` => `[`*in* | *out*`]` *dev* `BooleanValue`
  * `Host` => `[`*src* | *dst*`]` *host* `BooleanValue`
  * `Network` => `[`*src* | *dst*`]` *net* `BooleanValue`
  * `Port` => `[`*src* | *dst*`]` *port* `BooleanValue`
  * `Protocol` => *ip* | *icmp* | *tcp* `[Port]` | *udp* `[Port]`
  * `BooleanValue` => *not* *`<`value`>`* | *`<`value`>`* *and* *`<`value`>`* | *`<`value`>`* *or* *`<`value`>`*

 Values can be:
  * `Device` => `[`_alphas_`][`_alphanums_-.`_]*`
  * `Host` => `IpAddress` | `[`_alphas_`][`_alphanums_-.`_]*`
  * `Network` => `IpAddress` */* ( `IpAddress` | `[`_nums_`]{`1,2`}` ) | `IpAddress` *netmask* `IpAddress`
  * `Port` => `[`_nums_`]{`1,5`}`

 With:
  * `IpAddress` => `[`_nums_`]{`1,3`}` *.* `[`_nums_`]{`1,3`}` *.* `[`_nums_`]{`1,3`}` *.* `[`_nums_`]{`1,3`}`

===== Examples =====

 Capture HTTP traffic:

 {{{
tcp port 80 or 443
 }}}

 Capture SIP requests from _10.0.0.0/8_ to _1.2.3.4_ or _2.3.4.5_ on network device _eth1_:

 {{{
dev eth1 and src net 10.0.0.0/8 and dst host 1.2.3.4 or 2.3.4.5 and udp dst port 5060
 }}}

 {{{
[DEBUG] iptables -t filter -A PROXYSHARK9213 -j NFQUEUE --queue-num 1234
[DEBUG] iptables -t filter -A PROXYSHARK6054 -p udp --dport 5060 -j PROXYSHARK9213
[DEBUG] iptables -t filter -A PROXYSHARK1240 -d 2.3.4.5 -j PROXYSHARK6054
[DEBUG] iptables -t filter -A PROXYSHARK1240 -d 1.2.3.4 -j PROXYSHARK6054
[DEBUG] iptables -t filter -A PROXYSHARK9274 -s 10.0.0.0/8 -j PROXYSHARK1240
[DEBUG] iptables -t filter -A PROXYSHARK5027 -o eth1 -j PROXYSHARK9274
[DEBUG] iptables -t filter -A PROXYSHARK5027 -i eth1 -j PROXYSHARK9274
[DEBUG] iptables -t filter -I INPUT 1 -j PROXYSHARK5027
[DEBUG] iptables -t filter -I OUTPUT 1 -j PROXYSHARK5027
[DEBUG] iptables -t filter -I FORWARD 1 -j PROXYSHARK5027
 }}}

==== `set packet filter <packet-filter>` ====

 Set the packet filter.

 This filter is almost like a _Wireshark_ [http://wiki.wireshark.org/DisplayFilters display filter]. You can use it to select captured packets based on dissection criteria.

 The formal grammar is:
  * `PacketFilter` => `[`*any* | `BooleanCondition]`
  * `BooleanCondition` => `Operand` `[Operator` `Value]`
  * `Operand` => *raw* | `Item` | `[`( *len* | *nb* ) *(* `Item` *)*`]`
  * `Item` => `ItemName` `[`*`[`* `AttributeName` *`]`*`]` `[`*`[`* `SliceKey` *`]`*`]`
  * `ItemName` => `[`_alpha_.`_]`+
  * `AttributeName` => `[`_alpha_`]`+
  * `SliceKey` => `[`-_nums_`]*` *:* `[`-_nums_`]*`
  * `Operator` => *`==`* | *`=`* | *`!=`* | *`^=`* | *`*=`* | *`$=`* | *`<=`* | *`<`* | *`>=`* | *`>`*
  * `Value` => `QuotedValue` | `UnquotedValue`
  * `QuotedValue` => `"[`_printable_`]`+`"` | `'[`_printable_`]`+`'`
  * `UnquotedValue` => `[`_printable_without_space_`]`+

===== Examples =====

 Select ICMP packets with TTL < 32:

 {{{
icmp and ip.ttl < 32
 }}}

 Select packets longer than 1000 characters and containing raw string `"</html>\r\n"`:

 {{{
len(raw) > 1000 and raw*='</html>\r\n'
 }}}

 Select HTTP GET requests with URI starting with _/index.php?page=_ and User-Agent shorter than 10 characters:

 {{{
http.request.method=GET and http.request.uri^=/index.php?page= and len(http.user_agent) < 10
 }}}

==== `set field filter <field-filter>` ====

 Set the field filter.

 This filter is only available in web-driven mode. It's just a [http://docs.python.org/2/howto/regex.html regular expression] that selects which items of the packets (protocols or fields) will be sent to the web proxy (and so, which ones will be editable/repeatable).

 Note that if no `^` or `$` characters are found, they will be automatically added at the beginning or at the end of the filter.

===== Examples =====

 Forward only the fields related to SIP:

 {{{
sip.*
 }}}

 Forward only the IP and TCP protocols, and all the fields from the HTTP layer:

 {{{
ip$|tcp$|http.*
 }}}

==== `b|breakpoint [<breakpoint-id>]|[<breakpoint-id> <packet-filter>]` ====

 If a packet filter is provided, create a new breakpoint based on the given expression. Otherwise, print a list of all existing breakpoints (equivalent to [Usage#i%7Cinfo_%5Bparameter%5D `info breakpoints`]).

 

 The first argument is a unique identifier for the new breakpoint.

 If no packet filter is given, print a list of the existing breakpoints.

==== `a|action [<action-id>]|[<action-id> <breakpoint-id>]|[<action-id> <breakpoint-id> <python-expression>]` ====

 Associate a new action with a breakpoint. The first argument must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_. The second argument is the code to execute when the action is triggered. If no code is given, print the action associated with the breakpoint. See the [TechnicalDescription technical description] for details about actions and breakpoints.

==== `c|capture [bpf-filter]` ====

 Start a new capture. The argument will be parsed as a BPF filter and converted into a set of netfilter rules redirecting the matching packets to the selected netfilter queue. See the [TechnicalDescription technical description] for details about BPF filters and netfilter rules.

==== `en | enable <breakpoint-id>` ====

 Enable an existing breakpoint. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_.

==== `dis | disable <breakpoint-id>` ====

 Disable an existing breakpoint. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_. 

==== `d | delete <type> <breakpoint-id>` ====

 Delete a breakpoint or an action. The _type_ argument can be _b_ or _breakpoint_ for a breakpoint and _a_ or _action_ for an action. The _breakpoint-id_ must be a valid breakpoint identifier returned by the command _b_ or _breakpoint_.

==== `pkts | packets <filter-expression>` ====

 Return all the previously captured packets. You can specify a filter expression to select a subset of packets. See the [TechnicalDescription technical description] for details about filter expressions.

==== `pkt | packet` ====

 A special variable containing the last dissected packet.

==== `accept` ====

 Accept the current packet and resume the capture.

==== `drop` ====

 Drop the current packet and resume the capture.

==== `break` ====

 Pause the current capture.

==== `stop` ====

 Stop the current capture.

==== Examples ====

 Capture HTTP traffic from or to _www.google.com_ and break on index requests:

 {{{
>>> b 1 pkt.http.method == "GET" and pkt.http.uri == "/"
new breakpoint with id 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> c host www.google.com and port 80
capturing...
at breakpoint 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> 
 }}}

 Print the captured packet:

 {{{
>>> pkt
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET / HTTP/1.1
>>> print pkt
[todo: put the dissected fields here]
 }}}

 Modify the URI and let the packet go:

 {{{
>>> pkt.http.uri = "/modified.php"
>>> pkt
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET /modified.php HTTP/1.1
>>> accept
capturing...
 }}}

 Automatically modify the URI when an index request is encountered:

 {{{
>>> b 1 pkt.http.method == "GET" and pkt.http.uri == "/"
new breakpoint with id 1: pkt.http.method == "GET" and pkt.http.uri == "/"
>>> a 1 pkt.http.uri = "/modified.php"; accept()
new action on breakpoint 1: pkt.http.uri = "/modified.php"; accept()
>>> c host www.google.com and port 80
capturing...
at breakpoint 1: running action
at breakpoint 1: running action
at breakpoint 1: running action
 }}}

 Get all the TCP packets:

 {{{
>>> pkts pkt.tcp
[4 packets]
0.000000 192.168.98.102 -> 74.125.39.104 TCP 56511 > http [SYN] Seq=0 Win=5840 Len=0 MSS=1460 TSV=8507835 TSER=0 WS=1
0.048718 74.125.39.104 -> 192.168.98.102 TCP http > 56511 [SYN, ACK] Seq=0 Ack=1 Win=5672 Len=0 MSS=1430 TSV=2275473486 TSER=8507835 WS=6
0.048905 192.168.98.102 -> 74.125.39.104 TCP 56511 > http [ACK] Seq=1 Ack=1 Win=5840 Len=0 TSV=8507840 TSER=2275473486
0.089290 192.168.98.102 -> 74.125.39.104 HTTP GET / HTTP/1.1
 }}}

 Get the TCP packets where the SYN flag is set:

 {{{
>>> pkts pkt.tcp.flags.syn
 }}}
 
 Get the HTTP packets where the TTL is _64_, the method is _POST_ and the URI is _/index.php_:

 {{{
>>> pkts pkt.ip.ttl == 64 and pkt.http.method == "POST" and pkt.http.uri == "/index.php"
 }}}

== Scripting interface `[UPCOMING]` ==

You can also write Python scripts based on proxyshark. The available functions are the same than in command-line mode.

==== Example ====

 {{{
#!~/proxyshark.py -v

# define a complex action
def myaction():
    pkt.ip.ttl = 64
    pkt.http.uri = "/modified.php"
    # add any other action here
    # ...
    # accept the packet
    accept()
    # stop the capture after 10 packets
    if len(pkts) == 10:
        print "Capture done."
        stop()

# define a breakpoint and an action
b mybreak pkt.http.method == "GET" and pkt.http.uri == "/"
a mybreak myaction()

# run the capture
c host www.google.fr and port 80
print "End."
 }}}

 {{{
root@debian:~$ python proxyshark.py -v myscript.py
new breakpoint with id 'mybreak': pkt.http.method == "GET" and pkt.http.uri == "/"
new action on breakpoint 'mybreak': myaction()
capturing...
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
at breakpoint 'mybreak': myaction()
Capture done.
End.
root@debian:~$
 }}}